using System;
using Microsoft.SPOT;

namespace JollySamurai.I2C.Devices.InvenSense
{
    public class DigitalMotionProcessor
    {

        private const long QUAT_ERROR_THRESH = 1L << 24;
        private const long QUAT_MAG_SQ_NORMALIZED = 1L << 28;
        private const long QUAT_MAG_SQ_MIN = QUAT_MAG_SQ_NORMALIZED - QUAT_ERROR_THRESH;
        private const long QUAT_MAG_SQ_MAX = QUAT_MAG_SQ_NORMALIZED + QUAT_ERROR_THRESH;

        #region Constants
        public static readonly long GyroScaleFactor = 46850825L * 200 / MaximumSampleRate;

        public const ushort MaximumSampleRate = 200;
        public const ushort DefaultFifoRate = 20;

        private const int MemoryBankSize = 256;
        private const int MemoryChunkLength = 16;
        private const ushort MemoryStartAddress = 0x0400;
        private const int MaxPacketLength = 32;
        private const int ProgramLength = 3062;
        #endregion

        #region Firmware Constants
        private const int DINA30 = 0x30;
        private const int DINA38 = 0x38;
        private const int DINAAA = 0xaa;
        private const int DINAF1 = 0xf1;
        private const int DINADF = 0xdf;

        private const int D_0_22 = 22 + 512;
        private const int D_0_36 = 36;
        private const int D_0_52 = 52;
        private const int D_0_96 = 96;
        private const int D_0_104 = 104;
        private const int D_0_108 = 108;
        private const int D_0_163 = 163;
        private const int D_0_188 = 188;
        private const int D_0_192 = 192;
        private const int D_0_224 = 224;
        private const int D_0_228 = 228;
        private const int D_0_232 = 232;
        private const int D_0_236 = 236;

        private const int CFG_6 = 2753;
        private const int CFG_8 = 2718;
        private const int CFG_15 = 2727;
        private const int CFG_27 = 2742;
        private const int CFG_20 = 2224;
        private const int CFG_23 = 2745;
        private const int CFG_ANDROID_ORIENT_INT = 1853;
        private const int CFG_GYRO_RAW_DATA = 2722;
        private const int CFG_LP_QUAT = 2712;
        private const int CFG_MOTION_BIAS = 1208;

        private const int DINAAB = 0xab;
        private const int DINAF2 = 0xf2;
        private const int DINAFE = 0xfe;
        private const int DINA20 = 0x20;
        private const int DINA28 = 0x28;
        private const int DINA80 = 0x80;
        private const int DINA90 = 0x90;
        private const int DINAC0 = 0xb0;
        private const int DINAC2 = 0xb4;
        private const int DINBC2 = 0xc2;
        private const int DINBC4 = 0xc4;
        private const int DINBC6 = 0xc6;
        private const int DINBC0 = 0xc0;
        #endregion

        #region DMP memory
        private static readonly byte[] Program = new byte[ProgramLength] {
            /* bank # 0 */
            0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
            0x00, 0x65, 0x00, 0x54, 0xff, 0xef, 0x00, 0x00, 0xfa, 0x80, 0x00, 0x0b, 0x12, 0x82, 0x00, 0x01,
            0x03, 0x0c, 0x30, 0xc3, 0x0e, 0x8c, 0x8c, 0xe9, 0x14, 0xd5, 0x40, 0x02, 0x13, 0x71, 0x0f, 0x8e,
            0x38, 0x83, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83, 0x25, 0x8e, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83,
            0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xa9, 0xd6, 0x24, 0x00, 0x04, 0x00, 0x1a, 0x82, 0x79, 0xa1,
            0x00, 0x00, 0x00, 0x3c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x83, 0x6f, 0xa2,
            0x00, 0x3e, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xca, 0xe3, 0x09, 0x3e, 0x80, 0x00, 0x00,
            0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
            0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x6e, 0x00, 0x00, 0x06, 0x92, 0x0a, 0x16, 0xc0, 0xdf,
            0xff, 0xff, 0x02, 0x56, 0xfd, 0x8c, 0xd3, 0x77, 0xff, 0xe1, 0xc4, 0x96, 0xe0, 0xc5, 0xbe, 0xaa,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x2b, 0x00, 0x00, 0x16, 0x57, 0x00, 0x00, 0x03, 0x59,
            0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xfa, 0x00, 0x02, 0x6c, 0x1d, 0x00, 0x00, 0x00, 0x00,
            0x3f, 0xff, 0xdf, 0xeb, 0x00, 0x3e, 0xb3, 0xb6, 0x00, 0x0d, 0x22, 0x78, 0x00, 0x00, 0x2f, 0x3c,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x42, 0xb5, 0x00, 0x00, 0x39, 0xa2, 0x00, 0x00, 0xb3, 0x65,
            0xd9, 0x0e, 0x9f, 0xc9, 0x1d, 0xcf, 0x4c, 0x34, 0x30, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
            0x3b, 0xb6, 0x7a, 0xe8, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            /* bank # 1 */
            0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0xfa, 0x92, 0x10, 0x00, 0x22, 0x5e, 0x00, 0x0d, 0x22, 0x9f,
            0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0xff, 0x46, 0x00, 0x00, 0x63, 0xd4, 0x00, 0x00,
            0x10, 0x00, 0x00, 0x00, 0x04, 0xd6, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x72, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x06, 0x00, 0x02, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x64, 0x00, 0x20, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x32, 0xf8, 0x98, 0x00, 0x00, 0xff, 0x65, 0x00, 0x00, 0x83, 0x0f, 0x00, 0x00,
            0xff, 0x9b, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
            0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xb2, 0x6a, 0x00, 0x02, 0x00, 0x00,
            0x00, 0x01, 0xfb, 0x83, 0x00, 0x68, 0x00, 0x00, 0x00, 0xd9, 0xfc, 0x00, 0x7c, 0xf1, 0xff, 0x83,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x64, 0x03, 0xe8, 0x00, 0x64, 0x00, 0x28,
            0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x16, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x10, 0x00,
            /* bank # 2 */
            0x00, 0x28, 0x00, 0x00, 0xff, 0xff, 0x45, 0x81, 0xff, 0xff, 0xfa, 0x72, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0x05, 0xba, 0xc6, 0x00, 0x47, 0x78, 0xa2,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
            0x00, 0x00, 0x25, 0x4d, 0x00, 0x2f, 0x70, 0x6d, 0x00, 0x00, 0x05, 0xae, 0x00, 0x0c, 0x02, 0xd0,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x64, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0e,
            0x00, 0x00, 0x0a, 0xc7, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0xff, 0xff, 0xff, 0x9c,
            0x00, 0x00, 0x0b, 0x2b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64,
            0xff, 0xe5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            /* bank # 3 */
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x24, 0x26, 0xd3,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x96, 0x00, 0x3c,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0c, 0x0a, 0x4e, 0x68, 0xcd, 0xcf, 0x77, 0x09, 0x50, 0x16, 0x67, 0x59, 0xc6, 0x19, 0xce, 0x82,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xd7, 0x84, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x93, 0x8f, 0x9d, 0x1e, 0x1b, 0x1c, 0x19,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x18, 0x85, 0x00, 0x00, 0x40, 0x00,
            0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x67, 0x7d, 0xdf, 0x7e, 0x72, 0x90, 0x2e, 0x55, 0x4c, 0xf6, 0xe6, 0x88,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

            /* bank # 4 */
            0xd8, 0xdc, 0xb4, 0xb8, 0xb0, 0xd8, 0xb9, 0xab, 0xf3, 0xf8, 0xfa, 0xb3, 0xb7, 0xbb, 0x8e, 0x9e,
            0xae, 0xf1, 0x32, 0xf5, 0x1b, 0xf1, 0xb4, 0xb8, 0xb0, 0x80, 0x97, 0xf1, 0xa9, 0xdf, 0xdf, 0xdf,
            0xaa, 0xdf, 0xdf, 0xdf, 0xf2, 0xaa, 0xc5, 0xcd, 0xc7, 0xa9, 0x0c, 0xc9, 0x2c, 0x97, 0xf1, 0xa9,
            0x89, 0x26, 0x46, 0x66, 0xb2, 0x89, 0x99, 0xa9, 0x2d, 0x55, 0x7d, 0xb0, 0xb0, 0x8a, 0xa8, 0x96,
            0x36, 0x56, 0x76, 0xf1, 0xba, 0xa3, 0xb4, 0xb2, 0x80, 0xc0, 0xb8, 0xa8, 0x97, 0x11, 0xb2, 0x83,
            0x98, 0xba, 0xa3, 0xf0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xb2, 0xb9, 0xb4, 0x98, 0x83, 0xf1,
            0xa3, 0x29, 0x55, 0x7d, 0xba, 0xb5, 0xb1, 0xa3, 0x83, 0x93, 0xf0, 0x00, 0x28, 0x50, 0xf5, 0xb2,
            0xb6, 0xaa, 0x83, 0x93, 0x28, 0x54, 0x7c, 0xf1, 0xb9, 0xa3, 0x82, 0x93, 0x61, 0xba, 0xa2, 0xda,
            0xde, 0xdf, 0xdb, 0x81, 0x9a, 0xb9, 0xae, 0xf5, 0x60, 0x68, 0x70, 0xf1, 0xda, 0xba, 0xa2, 0xdf,
            0xd9, 0xba, 0xa2, 0xfa, 0xb9, 0xa3, 0x82, 0x92, 0xdb, 0x31, 0xba, 0xa2, 0xd9, 0xba, 0xa2, 0xf8,
            0xdf, 0x85, 0xa4, 0xd0, 0xc1, 0xbb, 0xad, 0x83, 0xc2, 0xc5, 0xc7, 0xb8, 0xa2, 0xdf, 0xdf, 0xdf,
            0xba, 0xa0, 0xdf, 0xdf, 0xdf, 0xd8, 0xd8, 0xf1, 0xb8, 0xaa, 0xb3, 0x8d, 0xb4, 0x98, 0x0d, 0x35,
            0x5d, 0xb2, 0xb6, 0xba, 0xaf, 0x8c, 0x96, 0x19, 0x8f, 0x9f, 0xa7, 0x0e, 0x16, 0x1e, 0xb4, 0x9a,
            0xb8, 0xaa, 0x87, 0x2c, 0x54, 0x7c, 0xba, 0xa4, 0xb0, 0x8a, 0xb6, 0x91, 0x32, 0x56, 0x76, 0xb2,
            0x84, 0x94, 0xa4, 0xc8, 0x08, 0xcd, 0xd8, 0xb8, 0xb4, 0xb0, 0xf1, 0x99, 0x82, 0xa8, 0x2d, 0x55,
            0x7d, 0x98, 0xa8, 0x0e, 0x16, 0x1e, 0xa2, 0x2c, 0x54, 0x7c, 0x92, 0xa4, 0xf0, 0x2c, 0x50, 0x78,
            /* bank # 5 */
            0xf1, 0x84, 0xa8, 0x98, 0xc4, 0xcd, 0xfc, 0xd8, 0x0d, 0xdb, 0xa8, 0xfc, 0x2d, 0xf3, 0xd9, 0xba,
            0xa6, 0xf8, 0xda, 0xba, 0xa6, 0xde, 0xd8, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xf3, 0xc8,
            0x41, 0xda, 0xa6, 0xc8, 0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0x82, 0xa8, 0x92, 0xf5, 0x2c, 0x54, 0x88,
            0x98, 0xf1, 0x35, 0xd9, 0xf4, 0x18, 0xd8, 0xf1, 0xa2, 0xd0, 0xf8, 0xf9, 0xa8, 0x84, 0xd9, 0xc7,
            0xdf, 0xf8, 0xf8, 0x83, 0xc5, 0xda, 0xdf, 0x69, 0xdf, 0x83, 0xc1, 0xd8, 0xf4, 0x01, 0x14, 0xf1,
            0xa8, 0x82, 0x4e, 0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x28, 0x97, 0x88, 0xf1,
            0x09, 0xf4, 0x1c, 0x1c, 0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x29,
            0xf4, 0x0d, 0xd8, 0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc2, 0x03, 0xd8, 0xde, 0xdf, 0x1a,
            0xd8, 0xf1, 0xa2, 0xfa, 0xf9, 0xa8, 0x84, 0x98, 0xd9, 0xc7, 0xdf, 0xf8, 0xf8, 0xf8, 0x83, 0xc7,
            0xda, 0xdf, 0x69, 0xdf, 0xf8, 0x83, 0xc3, 0xd8, 0xf4, 0x01, 0x14, 0xf1, 0x98, 0xa8, 0x82, 0x2e,
            0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x50, 0x97, 0x88, 0xf1, 0x09, 0xf4, 0x1c,
            0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf8, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x49, 0xf4, 0x0d, 0xd8,
            0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc4, 0x03, 0xd8, 0xde, 0xdf, 0xd8, 0xf1, 0xad, 0x88,
            0x98, 0xcc, 0xa8, 0x09, 0xf9, 0xd9, 0x82, 0x92, 0xa8, 0xf5, 0x7c, 0xf1, 0x88, 0x3a, 0xcf, 0x94,
            0x4a, 0x6e, 0x98, 0xdb, 0x69, 0x31, 0xda, 0xad, 0xf2, 0xde, 0xf9, 0xd8, 0x87, 0x95, 0xa8, 0xf2,
            0x21, 0xd1, 0xda, 0xa5, 0xf9, 0xf4, 0x17, 0xd9, 0xf1, 0xae, 0x8e, 0xd0, 0xc0, 0xc3, 0xae, 0x82,
            /* bank # 6 */
            0xc6, 0x84, 0xc3, 0xa8, 0x85, 0x95, 0xc8, 0xa5, 0x88, 0xf2, 0xc0, 0xf1, 0xf4, 0x01, 0x0e, 0xf1,
            0x8e, 0x9e, 0xa8, 0xc6, 0x3e, 0x56, 0xf5, 0x54, 0xf1, 0x88, 0x72, 0xf4, 0x01, 0x15, 0xf1, 0x98,
            0x45, 0x85, 0x6e, 0xf5, 0x8e, 0x9e, 0x04, 0x88, 0xf1, 0x42, 0x98, 0x5a, 0x8e, 0x9e, 0x06, 0x88,
            0x69, 0xf4, 0x01, 0x1c, 0xf1, 0x98, 0x1e, 0x11, 0x08, 0xd0, 0xf5, 0x04, 0xf1, 0x1e, 0x97, 0x02,
            0x02, 0x98, 0x36, 0x25, 0xdb, 0xf9, 0xd9, 0x85, 0xa5, 0xf3, 0xc1, 0xda, 0x85, 0xa5, 0xf3, 0xdf,
            0xd8, 0x85, 0x95, 0xa8, 0xf3, 0x09, 0xda, 0xa5, 0xfa, 0xd8, 0x82, 0x92, 0xa8, 0xf5, 0x78, 0xf1,
            0x88, 0x1a, 0x84, 0x9f, 0x26, 0x88, 0x98, 0x21, 0xda, 0xf4, 0x1d, 0xf3, 0xd8, 0x87, 0x9f, 0x39,
            0xd1, 0xaf, 0xd9, 0xdf, 0xdf, 0xfb, 0xf9, 0xf4, 0x0c, 0xf3, 0xd8, 0xfa, 0xd0, 0xf8, 0xda, 0xf9,
            0xf9, 0xd0, 0xdf, 0xd9, 0xf9, 0xd8, 0xf4, 0x0b, 0xd8, 0xf3, 0x87, 0x9f, 0x39, 0xd1, 0xaf, 0xd9,
            0xdf, 0xdf, 0xf4, 0x1d, 0xf3, 0xd8, 0xfa, 0xfc, 0xa8, 0x69, 0xf9, 0xf9, 0xaf, 0xd0, 0xda, 0xde,
            0xfa, 0xd9, 0xf8, 0x8f, 0x9f, 0xa8, 0xf1, 0xcc, 0xf3, 0x98, 0xdb, 0x45, 0xd9, 0xaf, 0xdf, 0xd0,
            0xf8, 0xd8, 0xf1, 0x8f, 0x9f, 0xa8, 0xca, 0xf3, 0x88, 0x09, 0xda, 0xaf, 0x8f, 0xcb, 0xf8, 0xd8,
            0xf2, 0xad, 0x97, 0x8d, 0x0c, 0xd9, 0xa5, 0xdf, 0xf9, 0xba, 0xa6, 0xf3, 0xfa, 0xf4, 0x12, 0xf2,
            0xd8, 0x95, 0x0d, 0xd1, 0xd9, 0xba, 0xa6, 0xf3, 0xfa, 0xda, 0xa5, 0xf2, 0xc1, 0xba, 0xa6, 0xf3,
            0xdf, 0xd8, 0xf1, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xca, 0xf3, 0x49, 0xda, 0xa6, 0xcb,
            0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0xd8, 0xad, 0x84, 0xf2, 0xc0, 0xdf, 0xf1, 0x8f, 0xcb, 0xc3, 0xa8,
            /* bank # 7 */
            0xb2, 0xb6, 0x86, 0x96, 0xc8, 0xc1, 0xcb, 0xc3, 0xf3, 0xb0, 0xb4, 0x88, 0x98, 0xa8, 0x21, 0xdb,
            0x71, 0x8d, 0x9d, 0x71, 0x85, 0x95, 0x21, 0xd9, 0xad, 0xf2, 0xfa, 0xd8, 0x85, 0x97, 0xa8, 0x28,
            0xd9, 0xf4, 0x08, 0xd8, 0xf2, 0x8d, 0x29, 0xda, 0xf4, 0x05, 0xd9, 0xf2, 0x85, 0xa4, 0xc2, 0xf2,
            0xd8, 0xa8, 0x8d, 0x94, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xf2, 0xd8, 0x87, 0x21, 0xd8, 0xf4, 0x0a,
            0xd8, 0xf2, 0x84, 0x98, 0xa8, 0xc8, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xd8, 0xf3, 0xa4, 0xc8, 0xbb,
            0xaf, 0xd0, 0xf2, 0xde, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xd8, 0xf1, 0xb8, 0xf6,
            0xb5, 0xb9, 0xb0, 0x8a, 0x95, 0xa3, 0xde, 0x3c, 0xa3, 0xd9, 0xf8, 0xd8, 0x5c, 0xa3, 0xd9, 0xf8,
            0xd8, 0x7c, 0xa3, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa5, 0xd9, 0xdf, 0xda, 0xfa, 0xd8, 0xb1,
            0x85, 0x30, 0xf7, 0xd9, 0xde, 0xd8, 0xf8, 0x30, 0xad, 0xda, 0xde, 0xd8, 0xf2, 0xb4, 0x8c, 0x99,
            0xa3, 0x2d, 0x55, 0x7d, 0xa0, 0x83, 0xdf, 0xdf, 0xdf, 0xb5, 0x91, 0xa0, 0xf6, 0x29, 0xd9, 0xfb,
            0xd8, 0xa0, 0xfc, 0x29, 0xd9, 0xfa, 0xd8, 0xa0, 0xd0, 0x51, 0xd9, 0xf8, 0xd8, 0xfc, 0x51, 0xd9,
            0xf9, 0xd8, 0x79, 0xd9, 0xfb, 0xd8, 0xa0, 0xd0, 0xfc, 0x79, 0xd9, 0xfa, 0xd8, 0xa1, 0xf9, 0xf9,
            0xf9, 0xf9, 0xf9, 0xa0, 0xda, 0xdf, 0xdf, 0xdf, 0xd8, 0xa1, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xac,
            0xde, 0xf8, 0xad, 0xde, 0x83, 0x93, 0xac, 0x2c, 0x54, 0x7c, 0xf1, 0xa8, 0xdf, 0xdf, 0xdf, 0xf6,
            0x9d, 0x2c, 0xda, 0xa0, 0xdf, 0xd9, 0xfa, 0xdb, 0x2d, 0xf8, 0xd8, 0xa8, 0x50, 0xda, 0xa0, 0xd0,
            0xde, 0xd9, 0xd0, 0xf8, 0xf8, 0xf8, 0xdb, 0x55, 0xf8, 0xd8, 0xa8, 0x78, 0xda, 0xa0, 0xd0, 0xdf,
            /* bank # 8 */
            0xd9, 0xd0, 0xfa, 0xf8, 0xf8, 0xf8, 0xf8, 0xdb, 0x7d, 0xf8, 0xd8, 0x9c, 0xa8, 0x8c, 0xf5, 0x30,
            0xdb, 0x38, 0xd9, 0xd0, 0xde, 0xdf, 0xa0, 0xd0, 0xde, 0xdf, 0xd8, 0xa8, 0x48, 0xdb, 0x58, 0xd9,
            0xdf, 0xd0, 0xde, 0xa0, 0xdf, 0xd0, 0xde, 0xd8, 0xa8, 0x68, 0xdb, 0x70, 0xd9, 0xdf, 0xdf, 0xa0,
            0xdf, 0xdf, 0xd8, 0xf1, 0xa8, 0x88, 0x90, 0x2c, 0x54, 0x7c, 0x98, 0xa8, 0xd0, 0x5c, 0x38, 0xd1,
            0xda, 0xf2, 0xae, 0x8c, 0xdf, 0xf9, 0xd8, 0xb0, 0x87, 0xa8, 0xc1, 0xc1, 0xb1, 0x88, 0xa8, 0xc6,
            0xf9, 0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xa8,
            0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xf7, 0x8d, 0x9d, 0xad, 0xf8, 0x18, 0xda,
            0xf2, 0xae, 0xdf, 0xd8, 0xf7, 0xad, 0xfa, 0x30, 0xd9, 0xa4, 0xde, 0xf9, 0xd8, 0xf2, 0xae, 0xde,
            0xfa, 0xf9, 0x83, 0xa7, 0xd9, 0xc3, 0xc5, 0xc7, 0xf1, 0x88, 0x9b, 0xa7, 0x7a, 0xad, 0xf7, 0xde,
            0xdf, 0xa4, 0xf8, 0x84, 0x94, 0x08, 0xa7, 0x97, 0xf3, 0x00, 0xae, 0xf2, 0x98, 0x19, 0xa4, 0x88,
            0xc6, 0xa3, 0x94, 0x88, 0xf6, 0x32, 0xdf, 0xf2, 0x83, 0x93, 0xdb, 0x09, 0xd9, 0xf2, 0xaa, 0xdf,
            0xd8, 0xd8, 0xae, 0xf8, 0xf9, 0xd1, 0xda, 0xf3, 0xa4, 0xde, 0xa7, 0xf1, 0x88, 0x9b, 0x7a, 0xd8,
            0xf3, 0x84, 0x94, 0xae, 0x19, 0xf9, 0xda, 0xaa, 0xf1, 0xdf, 0xd8, 0xa8, 0x81, 0xc0, 0xc3, 0xc5,
            0xc7, 0xa3, 0x92, 0x83, 0xf6, 0x28, 0xad, 0xde, 0xd9, 0xf8, 0xd8, 0xa3, 0x50, 0xad, 0xd9, 0xf8,
            0xd8, 0xa3, 0x78, 0xad, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa1, 0xda, 0xde, 0xc3, 0xc5, 0xc7,
            0xd8, 0xa1, 0x81, 0x94, 0xf8, 0x18, 0xf2, 0xb0, 0x89, 0xac, 0xc3, 0xc5, 0xc7, 0xf1, 0xd8, 0xb8,
            /* bank # 9 */
            0xb4, 0xb0, 0x97, 0x86, 0xa8, 0x31, 0x9b, 0x06, 0x99, 0x07, 0xab, 0x97, 0x28, 0x88, 0x9b, 0xf0,
            0x0c, 0x20, 0x14, 0x40, 0xb0, 0xb4, 0xb8, 0xf0, 0xa8, 0x8a, 0x9a, 0x28, 0x50, 0x78, 0xb7, 0x9b,
            0xa8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xf1, 0xbb, 0xab,
            0x88, 0x00, 0x2c, 0x54, 0x7c, 0xf0, 0xb3, 0x8b, 0xb8, 0xa8, 0x04, 0x28, 0x50, 0x78, 0xf1, 0xb0,
            0x88, 0xb4, 0x97, 0x26, 0xa8, 0x59, 0x98, 0xbb, 0xab, 0xb3, 0x8b, 0x02, 0x26, 0x46, 0x66, 0xb0,
            0xb8, 0xf0, 0x8a, 0x9c, 0xa8, 0x29, 0x51, 0x79, 0x8b, 0x29, 0x51, 0x79, 0x8a, 0x24, 0x70, 0x59,
            0x8b, 0x20, 0x58, 0x71, 0x8a, 0x44, 0x69, 0x38, 0x8b, 0x39, 0x40, 0x68, 0x8a, 0x64, 0x48, 0x31,
            0x8b, 0x30, 0x49, 0x60, 0x88, 0xf1, 0xac, 0x00, 0x2c, 0x54, 0x7c, 0xf0, 0x8c, 0xa8, 0x04, 0x28,
            0x50, 0x78, 0xf1, 0x88, 0x97, 0x26, 0xa8, 0x59, 0x98, 0xac, 0x8c, 0x02, 0x26, 0x46, 0x66, 0xf0,
            0x89, 0x9c, 0xa8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xa9,
            0x88, 0x09, 0x20, 0x59, 0x70, 0xab, 0x11, 0x38, 0x40, 0x69, 0xa8, 0x19, 0x31, 0x48, 0x60, 0x8c,
            0xa8, 0x3c, 0x41, 0x5c, 0x20, 0x7c, 0x00, 0xf1, 0x87, 0x98, 0x19, 0x86, 0xa8, 0x6e, 0x76, 0x7e,
            0xa9, 0x99, 0x88, 0x2d, 0x55, 0x7d, 0xd8, 0xb1, 0xb5, 0xb9, 0xa3, 0xdf, 0xdf, 0xdf, 0xae, 0xd0,
            0xdf, 0xaa, 0xd0, 0xde, 0xf2, 0xab, 0xf8, 0xf9, 0xd9, 0xb0, 0x87, 0xc4, 0xaa, 0xf1, 0xdf, 0xdf,
            0xbb, 0xaf, 0xdf, 0xdf, 0xb9, 0xd8, 0xb1, 0xf1, 0xa3, 0x97, 0x8e, 0x60, 0xdf, 0xb0, 0x84, 0xf2,
            0xc8, 0xf8, 0xf9, 0xd9, 0xde, 0xd8, 0x93, 0x85, 0xf1, 0x4a, 0xb1, 0x83, 0xa3, 0x08, 0xb5, 0x83,
            /* bank # 10 */
            0x9a, 0x08, 0x10, 0xb7, 0x9f, 0x10, 0xd8, 0xf1, 0xb0, 0xba, 0xae, 0xb0, 0x8a, 0xc2, 0xb2, 0xb6,
            0x8e, 0x9e, 0xf1, 0xfb, 0xd9, 0xf4, 0x1d, 0xd8, 0xf9, 0xd9, 0x0c, 0xf1, 0xd8, 0xf8, 0xf8, 0xad,
            0x61, 0xd9, 0xae, 0xfb, 0xd8, 0xf4, 0x0c, 0xf1, 0xd8, 0xf8, 0xf8, 0xad, 0x19, 0xd9, 0xae, 0xfb,
            0xdf, 0xd8, 0xf4, 0x16, 0xf1, 0xd8, 0xf8, 0xad, 0x8d, 0x61, 0xd9, 0xf4, 0xf4, 0xac, 0xf5, 0x9c,
            0x9c, 0x8d, 0xdf, 0x2b, 0xba, 0xb6, 0xae, 0xfa, 0xf8, 0xf4, 0x0b, 0xd8, 0xf1, 0xae, 0xd0, 0xf8,
            0xad, 0x51, 0xda, 0xae, 0xfa, 0xf8, 0xf1, 0xd8, 0xb9, 0xb1, 0xb6, 0xa3, 0x83, 0x9c, 0x08, 0xb9,
            0xb1, 0x83, 0x9a, 0xb5, 0xaa, 0xc0, 0xfd, 0x30, 0x83, 0xb7, 0x9f, 0x10, 0xb5, 0x8b, 0x93, 0xf2,
            0x02, 0x02, 0xd1, 0xab, 0xda, 0xde, 0xd8, 0xf1, 0xb0, 0x80, 0xba, 0xab, 0xc0, 0xc3, 0xb2, 0x84,
            0xc1, 0xc3, 0xd8, 0xb1, 0xb9, 0xf3, 0x8b, 0xa3, 0x91, 0xb6, 0x09, 0xb4, 0xd9, 0xab, 0xde, 0xb0,
            0x87, 0x9c, 0xb9, 0xa3, 0xdd, 0xf1, 0xb3, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0xb0, 0x87, 0xa3, 0xa3,
            0xa3, 0xa3, 0xb2, 0x8b, 0xb6, 0x9b, 0xf2, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
            0xa3, 0xf1, 0xb0, 0x87, 0xb5, 0x9a, 0xa3, 0xf3, 0x9b, 0xa3, 0xa3, 0xdc, 0xba, 0xac, 0xdf, 0xb9,
            0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
            0xd8, 0xd8, 0xd8, 0xbb, 0xb3, 0xb7, 0xf1, 0xaa, 0xf9, 0xda, 0xff, 0xd9, 0x80, 0x9a, 0xaa, 0x28,
            0xb4, 0x80, 0x98, 0xa7, 0x20, 0xb7, 0x97, 0x87, 0xa8, 0x66, 0x88, 0xf0, 0x79, 0x51, 0xf1, 0x90,
            0x2c, 0x87, 0x0c, 0xa7, 0x81, 0x97, 0x62, 0x93, 0xf0, 0x71, 0x71, 0x60, 0x85, 0x94, 0x01, 0x29,
            /* bank # 11 */
            0x51, 0x79, 0x90, 0xa5, 0xf1, 0x28, 0x4c, 0x6c, 0x87, 0x0c, 0x95, 0x18, 0x85, 0x78, 0xa3, 0x83,
            0x90, 0x28, 0x4c, 0x6c, 0x88, 0x6c, 0xd8, 0xf3, 0xa2, 0x82, 0x00, 0xf2, 0x10, 0xa8, 0x92, 0x19,
            0x80, 0xa2, 0xf2, 0xd9, 0x26, 0xd8, 0xf1, 0x88, 0xa8, 0x4d, 0xd9, 0x48, 0xd8, 0x96, 0xa8, 0x39,
            0x80, 0xd9, 0x3c, 0xd8, 0x95, 0x80, 0xa8, 0x39, 0xa6, 0x86, 0x98, 0xd9, 0x2c, 0xda, 0x87, 0xa7,
            0x2c, 0xd8, 0xa8, 0x89, 0x95, 0x19, 0xa9, 0x80, 0xd9, 0x38, 0xd8, 0xa8, 0x89, 0x39, 0xa9, 0x80,
            0xda, 0x3c, 0xd8, 0xa8, 0x2e, 0xa8, 0x39, 0x90, 0xd9, 0x0c, 0xd8, 0xa8, 0x95, 0x31, 0x98, 0xd9,
            0x0c, 0xd8, 0xa8, 0x09, 0xd9, 0xff, 0xd8, 0x01, 0xda, 0xff, 0xd8, 0x95, 0x39, 0xa9, 0xda, 0x26,
            0xff, 0xd8, 0x90, 0xa8, 0x0d, 0x89, 0x99, 0xa8, 0x10, 0x80, 0x98, 0x21, 0xda, 0x2e, 0xd8, 0x89,
            0x99, 0xa8, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8, 0x86, 0x96, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8,
            0x87, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8, 0x82, 0x92, 0xf3, 0x41, 0x80, 0xf1, 0xd9, 0x2e, 0xd8,
            0xa8, 0x82, 0xf3, 0x19, 0x80, 0xf1, 0xd9, 0x2e, 0xd8, 0x82, 0xac, 0xf3, 0xc0, 0xa2, 0x80, 0x22,
            0xf1, 0xa6, 0x2e, 0xa7, 0x2e, 0xa9, 0x22, 0x98, 0xa8, 0x29, 0xda, 0xac, 0xde, 0xff, 0xd8, 0xa2,
            0xf2, 0x2a, 0xf1, 0xa9, 0x2e, 0x82, 0x92, 0xa8, 0xf2, 0x31, 0x80, 0xa6, 0x96, 0xf1, 0xd9, 0x00,
            0xac, 0x8c, 0x9c, 0x0c, 0x30, 0xac, 0xde, 0xd0, 0xde, 0xff, 0xd8, 0x8c, 0x9c, 0xac, 0xd0, 0x10,
            0xac, 0xde, 0x80, 0x92, 0xa2, 0xf2, 0x4c, 0x82, 0xa8, 0xf1, 0xca, 0xf2, 0x35, 0xf1, 0x96, 0x88,
            0xa6, 0xd9, 0x00, 0xd8, 0xf1, 0xff
        };
        #endregion

        #region Properties
        public bool IsInitialized
        {
            get
            {
                return _initialized;
            }
        }

        public bool IsEnabled
        {
            get
            {
                return _enabled;
            }
        }

        public ushort FifoRate
        {
            get
            {
                return _fifoRate;
            }
            set
            {
                byte[] regsEnd = SharedBuffers.B12;
                regsEnd[0] = DINAFE;
                regsEnd[1] = DINAF2;
                regsEnd[2] = DINAAB;
                regsEnd[3] = 0xC4;
                regsEnd[4] = DINAAA;
                regsEnd[5] = DINAF1;
                regsEnd[6] = DINADF;
                regsEnd[7] = DINADF;
                regsEnd[8] = 0xBB;
                regsEnd[9] = 0xAF;
                regsEnd[10] = DINADF;
                regsEnd[11] = DINADF;

                ushort div;

                if (value > MaximumSampleRate) {
                    return;
                }

                div = (ushort) (MaximumSampleRate / value - 1);

                byte[] tmp = SharedBuffers.B2;
                tmp[0] = (byte) ((div >> 8) & 0xFF);
                tmp[1] = (byte) (div & 0xFF);

                if (WriteMemory(D_0_22, tmp) != 0) {
                    return;
                }

                if (WriteMemory(CFG_6, regsEnd) != 0) {
                    return;
                }

                _fifoRate = value;
            }
        }
        #endregion

        #region Fields
        private BaseUnit _mpu;

        private bool _initialized;
        private bool _enabled;
        private ushort _sampleRate;
        private ushort _fifoRate;
        private Feature _featureMask = 0;
        private byte _packetLength;

        private byte[] _fifoBuffer;
        private byte[] _memWriteBuffer = new byte[2];
        private byte[] _memReadBuffer = new byte[2];
        #endregion

        #region Constructor
        public DigitalMotionProcessor(BaseUnit mpu)
        {
            _mpu = mpu;
        }
        #endregion

        #region Methods
        public bool Initialize()
        {
            /* To initialize the DMP:
             * 1. Call dmp_load_motion_driver_firmware(). This pushes the DMP image in
             *    inv_mpu_dmp_motion_driver.h into the MPU memory.
             * 2. Push the gyro and accel orientation matrix to the DMP.
             * 3. Register gesture callbacks. Don't worry, these callbacks won't be
             *    executed unless the corresponding feature is enabled.
             * 4. Call dmp_enable_feature(mask) to enable different features.
             * 5. Call dmp_set_fifo_rate(freq) to select a DMP output rate.
             * 6. Call any feature-specific control functions.
             *
             * To enable the DMP, just call mpu_set_dmp_state(1). This function can
             * be called repeatedly to enable and disable the DMP at runtime.
             *
             * The following is a short summary of the features supported in the DMP
             * image provided in inv_mpu_dmp_motion_driver.c:
             * DMP_FEATURE_LP_QUAT: Generate a gyro-only quaternion on the DMP at
             * 200Hz. Integrating the gyro data at higher rates reduces numerical
             * errors (compared to integration on the MCU at a lower sampling rate).
             * DMP_FEATURE_6X_LP_QUAT: Generate a gyro/accel quaternion on the DMP at
             * 200Hz. Cannot be used in combination with DMP_FEATURE_LP_QUAT.
             * DMP_FEATURE_TAP: Detect taps along the X, Y, and Z axes.
             * DMP_FEATURE_ANDROID_ORIENT: Google's screen rotation algorithm. Triggers
             * an event at the four orientations where the screen should rotate.
             * DMP_FEATURE_GYRO_CAL: Calibrates the gyro data after eight seconds of
             * no motion.
             * DMP_FEATURE_SEND_RAW_ACCEL: Add raw accelerometer data to the FIFO.
             * DMP_FEATURE_SEND_RAW_GYRO: Add raw gyro data to the FIFO.
             * DMP_FEATURE_SEND_CAL_GYRO: Add calibrated gyro data to the FIFO. Cannot
             * be used in combination with DMP_FEATURE_SEND_RAW_GYRO.
             */
            if (LoadMotionDriverFirmware() != 0) {
                return false;
            }

            // TODO:
            // dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_pdata.orientation));
            // dmp_register_tap_cb(tap_cb);
            // dmp_register_android_orient_cb(android_orient_cb);

            // force a collection
            Debug.GC(true);

            _initialized = true;

            return true;
        }

        public void Enable(Feature features, ushort fifoRate = DefaultFifoRate)
        {
            EnableFeatures(features);

            this.FifoRate = fifoRate;

            SetState(true);
        }

        public int EnableFeatures(Feature features)
        {
            byte[] buffer1 = SharedBuffers.B1;
            byte[] buffer4 = SharedBuffers.B4;
            byte[] buffer10 = SharedBuffers.B10;

            // TODO: all of these settings can probably be integrated into the default DMP image

            // set integration scale factor
            buffer4[0] = (byte) ((GyroScaleFactor >> 24) & 0xFF);
            buffer4[1] = (byte) ((GyroScaleFactor >> 16) & 0xFF);
            buffer4[2] = (byte) ((GyroScaleFactor >> 8) & 0xFF);
            buffer4[3] = (byte) (GyroScaleFactor & 0xFF);

            WriteMemory(D_0_104, buffer4);

            // send sensor data to the FIFO
            buffer10[0] = 0xA3;

            if ((features & Feature.SendRawAccelerometerData) != 0) {
                buffer10[1] = 0xC0;
                buffer10[2] = 0xC8;
                buffer10[3] = 0xC2;
            } else {
                buffer10[1] = 0xA3;
                buffer10[2] = 0xA3;
                buffer10[3] = 0xA3;
            }

            if ((features & Feature.SendAnyGyroData) != 0) {
                buffer10[4] = 0xC4;
                buffer10[5] = 0xCC;
                buffer10[6] = 0xC6;
            } else {
                buffer10[4] = 0xA3;
                buffer10[5] = 0xA3;
                buffer10[6] = 0xA3;
            }

            buffer10[7] = 0xA3;
            buffer10[8] = 0xA3;
            buffer10[9] = 0xA3;

            WriteMemory(CFG_15, buffer10);

            // send gesture data to the FIFO
            if ((features & (Feature.Tap | Feature.AndroidOrientation)) != 0) {
                buffer1[0] = DINA20;
            } else {
                buffer1[0] = 0xD8;
            }

            WriteMemory(CFG_27, buffer1);

            if ((features & Feature.CalibrateGyro) != 0) {
                EnableGyroCalibration(true);
            } else {
                EnableGyroCalibration(false);
            }

            if ((features & Feature.SendAnyGyroData) != 0) {
                if ((features & Feature.SendCalibratedGyroData) != 0) {
                    buffer4[0] = 0xB2;
                    buffer4[1] = 0x8B;
                    buffer4[2] = 0xB6;
                    buffer4[3] = 0x9B;
                } else {
                    buffer4[0] = DINAC0;
                    buffer4[1] = DINA80;
                    buffer4[2] = DINAC2;
                    buffer4[3] = DINA90;
                }

                WriteMemory(CFG_GYRO_RAW_DATA, buffer4);
            }

            if ((features & Feature.Tap) != 0) {
                /* Enable tap. */
                //tmp[0] = 0xF8;

                Debug.Print("TODO: FEATURE_TAP");
                /*mpu_write_mem(CFG_20, 1, tmp);
                dmp_set_tap_thresh(TAP_XYZ, 250);
                dmp_set_tap_axes(TAP_XYZ);
                dmp_set_tap_count(1);
                dmp_set_tap_time(100);
                dmp_set_tap_time_multi(500);

                dmp_set_shake_reject_thresh(GYRO_SF, 200);
                dmp_set_shake_reject_time(40);
                dmp_set_shake_reject_timeout(10);*/
            } else {
                buffer1[0] = 0xD8;
                WriteMemory(CFG_20, buffer1);
            }

            if ((features & Feature.AndroidOrientation) != 0) {
                buffer1[0] = 0xD9;
            } else {
                buffer1[0] = 0xD8;
            }

            WriteMemory(CFG_ANDROID_ORIENT_INT, buffer1);

            if ((features & Feature.Quaternion) != 0) {
                EnableQuaternion(true);
            } else {
                EnableQuaternion(false);
            }

            if ((features & Feature.Quaternion6x) != 0) {
                EnableQuaternion6x(true);
            } else {
                EnableQuaternion6x(false);
            }

            // pedometer is always enabled
            _featureMask = features | Feature.Pedometer;
            _packetLength = 0;

            _mpu.ResetFifo();

            if ((features & Feature.SendRawAccelerometerData) != 0) {
                _packetLength += 6;
            }

            if ((features & Feature.SendAnyGyroData) != 0) {
                _packetLength += 6;
            }

            if ((features & (Feature.Quaternion | Feature.Quaternion6x)) != 0) {
                _packetLength += 16;
            }

            if ((features & (Feature.Tap | Feature.AndroidOrientation)) != 0) {
                _packetLength += 4;
            }

            // resize the fifo buffer
            _fifoBuffer = new byte[_packetLength];

            return 0;
        }

        private int EnableGyroCalibration(bool enable)
        {
            byte[] buffer9 = SharedBuffers.B9;

            if (enable == true) {
                buffer9[0] = 0xB8;
                buffer9[1] = 0xAA;
                buffer9[2] = 0xB3;
                buffer9[3] = 0x8D;
                buffer9[4] = 0xB4;
                buffer9[5] = 0x98;
                buffer9[6] = 0x0D;
                buffer9[7] = 0x35;
                buffer9[8] = 0x5D;                
            } else {
                buffer9[0] = 0xB8;
                buffer9[1] = 0xAA;
                buffer9[2] = 0xAA;
                buffer9[3] = 0xAA;
                buffer9[4] = 0xB0;
                buffer9[5] = 0x88;
                buffer9[6] = 0xC3;
                buffer9[7] = 0xC5;
                buffer9[8] = 0xC7;
            }

            return WriteMemory(CFG_MOTION_BIAS, buffer9);
        }

        private int EnableQuaternion6x(bool enable)
        {
            byte[] buffer4 = SharedBuffers.B4;

            if (enable == true) {
                buffer4[0] = DINA20;
                buffer4[1] = DINA28;
                buffer4[2] = DINA30;
                buffer4[3] = DINA38;
            } else {
                buffer4[0] =
                    buffer4[1] =
                    buffer4[2] =
                    buffer4[3] = 0xA3;
            }

            WriteMemory(CFG_8, buffer4);

            return _mpu.ResetFifo();
        }

        private int EnableQuaternion(bool enable)
        {
            byte[] buffer4 = SharedBuffers.B4;

            if (enable == true) {
                buffer4[0] = DINBC0;
                buffer4[1] = DINBC2;
                buffer4[2] = DINBC4;
                buffer4[3] = DINBC6;
            } else {
                buffer4[0] =
                    buffer4[1] =
                    buffer4[2] =
                    buffer4[3] = 0x8B;
            }

            WriteMemory(CFG_LP_QUAT, buffer4);

            return _mpu.ResetFifo();
        }

        public int ReadFifo(short[] gyro, short[] accelerometer, long[] quaternion, ref int more)
        {
            int offset = 0;

            // get a packet
            if (_mpu.ReadFifoStream(_fifoBuffer, ref more) != 0) {
                return -1;
            }

            // parse DMP packet
            if ((_featureMask & (Feature.Quaternion | Feature.Quaternion6x)) != 0) {
                quaternion[0] = ((long) _fifoBuffer[0] << 24) | ((long) _fifoBuffer[1] << 16) | ((long) _fifoBuffer[2] << 8) | _fifoBuffer[3];
                quaternion[1] = ((long) _fifoBuffer[4] << 24) | ((long) _fifoBuffer[5] << 16) | ((long) _fifoBuffer[6] << 8) | _fifoBuffer[7];
                quaternion[2] = ((long) _fifoBuffer[8] << 24) | ((long) _fifoBuffer[9] << 16) | ((long) _fifoBuffer[10] << 8) | _fifoBuffer[11];
                quaternion[3] = ((long) _fifoBuffer[12] << 24) | ((long) _fifoBuffer[13] << 16) | ((long) _fifoBuffer[14] << 8) | _fifoBuffer[15];
                
                /*quaternion[0] = ((long) _fifoBuffer[3] << 24) | ((long) _fifoBuffer[2] << 16) | ((long) _fifoBuffer[1] << 8) | _fifoBuffer[0];
                quaternion[1] = ((long) _fifoBuffer[7] << 24) | ((long) _fifoBuffer[6] << 16) | ((long) _fifoBuffer[5] << 8) | _fifoBuffer[4];
                quaternion[2] = ((long) _fifoBuffer[11] << 24) | ((long) _fifoBuffer[10] << 16) | ((long) _fifoBuffer[9] << 8) | _fifoBuffer[8];
                quaternion[3] = ((long) _fifoBuffer[15] << 24) | ((long) _fifoBuffer[14] << 16) | ((long) _fifoBuffer[13] << 8) | _fifoBuffer[12];*/
                /*quaternion[0] = HydraMF.BitConverter.ToInt32(_fifoBuffer, 0);
                quaternion[1] = HydraMF.BitConverter.ToInt32(_fifoBuffer, 4);
                quaternion[2] = HydraMF.BitConverter.ToInt32(_fifoBuffer, 8);
                quaternion[3] = HydraMF.BitConverter.ToInt32(_fifoBuffer, 12);*/

                offset += 16;

                /* 
                 * We can detect a corrupted FIFO by monitoring the quaternion data and
                 * ensuring that the magnitude is always normalized to one. This
                 * shouldn't happen in normal operation, but if an I2C error occurs,
                 * the FIFO reads might become misaligned.
                 *
                 * Let's start by scaling down the quaternion data to avoid long long
                 * math.
                */

                /*long[] quat_q14 = new long[4];
                long quat_mag_sq;

                quat_q14[0] = quaternion[0] >> 16;
                quat_q14[1] = quaternion[1] >> 16;
                quat_q14[2] = quaternion[2] >> 16;
                quat_q14[3] = quaternion[3] >> 16;

                quat_mag_sq = quat_q14[0] * quat_q14[0] + quat_q14[1] * quat_q14[1] + quat_q14[2] * quat_q14[2] + quat_q14[3] * quat_q14[3];
                Debug.Print("MAG=" + quat_mag_sq.ToString() + " q0=" + quaternion[0].ToString() + " q1=" + quaternion[1].ToString() + " q2=" + quaternion[2].ToString() + " q3=" + quaternion[3].ToString());
                if ((quat_mag_sq < QUAT_MAG_SQ_MIN) || (quat_mag_sq > QUAT_MAG_SQ_MAX)) {
                    Debug.Print("CORRUPT");
                    // quaternion is outside of the acceptable threshold
                    _mpu.ResetFifo();
                    return -1;
                }*/
            }

            if ((_featureMask & Feature.SendRawAccelerometerData) == Feature.SendRawAccelerometerData) {
                accelerometer[0] = (short) ((_fifoBuffer[offset + 0] << 8) | _fifoBuffer[offset + 1]);
                accelerometer[1] = (short) ((_fifoBuffer[offset + 2] << 8) | _fifoBuffer[offset + 3]);
                accelerometer[2] = (short) ((_fifoBuffer[offset + 4] << 8) | _fifoBuffer[offset + 5]);

                offset += 6;
            }

            if ((_featureMask & Feature.SendAnyGyroData) != 0) {
                gyro[0] = (short) ((_fifoBuffer[offset + 0] << 8) | _fifoBuffer[offset + 1]);
                gyro[1] = (short) ((_fifoBuffer[offset + 2] << 8) | _fifoBuffer[offset + 3]);
                gyro[2] = (short) ((_fifoBuffer[offset + 4] << 8) | _fifoBuffer[offset + 5]);

                offset += 6;
            }

            // gesture data is at the end of the DMP packet. Parse it and call the gesture callbacks (if registered)
            // TODO
            /*if (dmp.feature_mask & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT))
                decode_gesture(fifo_data + ii);*/

            return 0;
        }

        private int LoadMotionDriverFirmware()
        {
            return LoadFirmware(ProgramLength, Program, MemoryStartAddress, MaximumSampleRate);
        }

        private int LoadFirmware(ushort length, byte[] firmware, ushort startAddress, ushort sampleRate)
        {
            if (_initialized == true) {
                // DMP should only be loaded once
                return -1;
            }

            // must divide evenly into st.hw->bank_size to avoid bank crossings
            byte[] currentWrite = new byte[MemoryChunkLength];
            byte[] currentRead = new byte[MemoryChunkLength];
            byte[] buffer2 = SharedBuffers.B2;
            ushort i, thisWrite;

            for (i = 0; i < length; i += thisWrite) {
                thisWrite = (ushort) System.Math.Min(MemoryChunkLength, length - i);

                // thisWrite can be less than MemoryChunkLength at the end of the program
                if (thisWrite != currentWrite.Length) {
                    currentWrite = new byte[thisWrite];
                    currentRead = new byte[thisWrite];
                }

                Array.Copy(firmware, i, currentWrite, 0, thisWrite);

                if (WriteMemory(i, currentWrite) != 0) {
                    return -1;
                }

                if (ReadMemory(i, currentRead) != 0) {
                    return -1;
                }

                if (Compare(currentWrite, currentRead, thisWrite) == false) {
                    return -2;
                }
            }

            // set program start address
            buffer2[0] = (byte) (startAddress >> 8);
            buffer2[1] = (byte) (startAddress & 0xFF);

            if (_mpu.WriteBytes(Register.ProgramStartAddress, buffer2) == false) {
                return -1;
            }

            _sampleRate = sampleRate;

            return 0;
        }

        private void SetState(bool enable)
        {
            if (_enabled == enable) {
                return;
            }

            if (enable == true) {
                if (_initialized == false) {
                    return;
                }

                // disable data ready interrupt
                _mpu.InterruptEnabled = false;

                // disable bypass mode
                _mpu.SetBypass(false);

                // keep constant sample rate, FIFO rate controlled by DMP
                _mpu.SampleRate = _sampleRate;

                // remove FIFO elements
                _mpu.WriteByte(0x23, 0);
                _enabled = true;

                // enable DMP interrupt
                _mpu.InterruptEnabled = true;

                _mpu.ResetFifo();
            } else {
                // disable DMP interrupt
                _mpu.InterruptEnabled = false;

                _enabled = false;

                _mpu.RestoreFifo();
                _mpu.ResetFifo();
            }
        }

        private int WriteMemory(ushort address, byte[] data)
        {
            if (_mpu.Sensors == Sensors.None) {
                return -1;
            }

            int dataLength = data.Length;

            _memWriteBuffer[0] = (byte) (address >> 8);
            _memWriteBuffer[1] = (byte) (address & 0xFF);

            // check bank boundaries
            if ((_memWriteBuffer[1] + dataLength) > MemoryBankSize) {
                return -1;
            }

            if (_mpu.WriteBytes(Register.MemoryBankSelect, _memWriteBuffer) == false) {
                return -1;
            }

            if (_mpu.WriteBytes(Register.MemoryReadWrite, data) == false) {
                return -1;
            }

            return 0;
        }

        private int ReadMemory(ushort address, byte[] data)
        {
            if (_mpu.Sensors == Sensors.None) {
                return -1;
            }

            int dataLength = data.Length;

            _memReadBuffer[0] = (byte) (address >> 8);
            _memReadBuffer[1] = (byte) (address & 0xFF);

            // check bank boundaries
            if ((_memReadBuffer[1] + dataLength) > MemoryBankSize) {
                return -1;
            }

            if (_mpu.WriteBytes(Register.MemoryBankSelect, _memReadBuffer) == false) {
                return -1;
            }

            if (_mpu.ReadBytes(Register.MemoryReadWrite, data) != dataLength) {
                return -1;
            }

            return 0;
        }

        private bool Compare(byte[] data1, byte[] data2, int length)
        {
            if (data1.Length != data2.Length) {
                return false;
            }

            for (int idx = 0; idx < length; idx++) {
                if (data1[idx] != data2[idx]) {
                    return false;
                }
            }

            return true;
        }

        // from https://github.com/jrowberg/i2cdevlib
        public void GetYawPitchRoll(float[] data, Quaternion q, float[] gravity)
        {
            // yaw: (about Z axis)
            data[0] = (float) System.Math.Atan2(2 * q.X * q.Y - 2 * q.W * q.Z, 2 * q.W * q.W + 2 * q.X * q.X - 1);
            //data[0] = (float) (2 * System.Math.Acos(q.W));

            // pitch: (nose up/down, about Y axis)
            data[1] = (float) System.Math.Atan(gravity[0] / (float) System.Math.Sqrt(gravity[1] * gravity[1] + gravity[2] * gravity[2]));

            // roll: (tilt left/right, about X axis)
            data[2] = (float) System.Math.Atan(gravity[1] / (float) System.Math.Sqrt(gravity[0] * gravity[0] + gravity[2] * gravity[2]));
        }

        // from https://github.com/jrowberg/i2cdevlib
        public void GetGravity(float[] v, Quaternion q)
        {
            v[0] = 2 * (q.X * q.Z - q.W * q.Y);
            v[1] = 2 * (q.W * q.X + q.Y * q.Z);
            v[2] = 2 * (q.W * q.W - q.X * q.X - q.Y * q.Y + q.Z * q.Z);
        }
        #endregion
    }
}
